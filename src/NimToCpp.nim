#? replace(sub = "\t", by = "  ")

#[

This file is able to convert Nim code to one single C file.
It uses the nim compiler + gcc + magic to work.

The goal is to use Nim to solve competitive programming challenges that only accept C/C++.

Idea:


We want to generate a small, portable blob of C code.

1. We generate the corresponding C++ code.
  nim cpp -c -d:danger -d:useMalloc --nimcache:. --gc:none cses.nim
2. We apply the preprocessor.
  g++ -E .\@mcses.nim.c -O3 -I C:\Users\vanyle\.choosenim\toolchains\nim-1.6.6\lib -o out.c 
3. We strip redundant symbols.
4. Done! we rename the file properly!

]#

import os, strformat, osproc, strutils, sets

proc isSymbolDef(line: string): bool = 
  if line.startswith("struct ") and line.endswith(" {"):
    return true
  if line.startswith("static N_INLINE(") and line.endswith(" {"):
    return true

  return false

proc getSymbolName(line: string): string =
  if line.startswith("struct"):
    return line.split(" ")[1].strip()
  if line.startswith("static N_INLINE("):
    return line.split(",",2)[1].split(")")[0].strip()
  return "???"
proc countSymbol(l: string, c: char): int =
  for i in l:
    if i == c: inc result


when isMainModule:
  let c = paramCount()
  if c != 1:
    echo "Usage: ./cses <input nim file>"
    quit()

  let s = paramStr(1)

  let tmp_dirname = "tmp_nimtocpp"

  createDir(tmp_dirname)


  var cppFiles: seq[string] # content of cppFiles generated by Nim.
  var cppIncludes: seq[string] # external include statement inside the cpp files (like include <stdio.h>)

  var (outp,code) = execCmdEx(fmt"nim cpp -c --os:any -d:danger -d:useMalloc --nimcache:./{tmp_dirname} --gc:none {s}")
  if code != 0:
    echo outp
    quit()

  for (kind, path) in walkDir(fmt"./{tmp_dirname}"):
    if path.endswith(".cpp"):
      var includes = ""
      var source = ""
      if fileExists(path):
        let f = readFile(path).split("\n")
        for l in f:
          let l2 = l.strip()
          if l2.startswith("#include <"):
            includes.add(l2 & "\n")
          elif l2.startswith("#include \"nimbase.h\""):
            continue # don't include nimbase!
          else:
            source.add(l & "\n")
        cppFiles.add(source)
        cppIncludes.add(includes)

  # Merge everything together and include nimbase manually:
  removeDir(tmp_dirname)
  #let nimbase_path = "C:/Users/vanyle/.choosenim/toolchains/nim-1.6.6/lib/nimbase.h"
  const nimbase_content = readFile("nimbase.h")

  var result = ""

  for j in cppIncludes:
    result.add(j)
  result.add("\n\n")

  result.add(nimbase_content)

  # Now, let's analyse cppFiles and remove lines and have duplicated definitions!

  var symbols: Hashset[string]

  for i in 0..<cppFiles.len:
    let lines = cppFiles[i].split("\n")
    var skippingSymbol = 0
    var output = ""

    for l in lines:
      let l2 = l.strip()
      if skippingSymbol > 0:
        skippingSymbol += l2.countSymbol('{') - l2.countSymbol('}')
        #echo "Should skip: ",l
        #output.add(l & "\n")
      elif isSymbolDef(l2):
        # Get symbol name
        let s = getSymbolName(l2)
        if s in symbols:
          # don't do declaration, symbol already found.
          # use {} count to find the end of the symbol.
          skippingSymbol = 1
          #echo "Should skip: ",l
          continue
        output.add(l & "\n")

        if s != "???":
          symbols.incl s
      else:
        output.add(l & "\n")

    cppFiles[i] = output

  #[

  struct TGenericSeq
  struct NimStringDesc : public TGenericSeq
  static N_INLINE(void, nimCopyMem)(void* dest, void* source, NI size) {

  ]#

  for i in cppFiles:
    result.add("\n// ---------\n")
    result.add("\n\n\n")
    result.add(i)

  echo fmt"C++ code available at: {s}_clean.cpp"
  writeFile(fmt"{s}_clean.cpp", result)